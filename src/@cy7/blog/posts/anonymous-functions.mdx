---
title: "Overusing anonymous functions"
slug: "anonymous-functions"
date: "2020-01-01"
---

import { CodeBlock } from "@cy7/blog";

Anonymous functions are something you come across often in JS. They're commonly used to tidy up callback-heavy code.

```js
// With named functions
array
  .filter(function notNull(x) {
    return x !== null;
  })
  .map(function double(x) {
    return x * 2;
  });

// The same code with anonymous functions
array
  .filter(x => x !== null)
  .map(x => x * 2);
```

I wrote the anonymous version of that code with arrow functions. That's also common. Note that arrow functions can have names too though.

<CodeBlock
  code={`
    // A named arrow function.
    // The name comes from the assigned variable.
    let double = x => x * 2;
    console.log(double.name);
  `}
  language="js"
  output={`
    "double"
  `}
/>

Function names can make stack traces easier to read. Here's what happens when a **named** callback throws an exception.

<CodeBlock
  code={`
    const doSomething = () => {
      throw new Error("oh no");
    };
    setTimeout(doSomething);
  `}
  language="js"
  output={`
    Error: oh no
        at doSomething (stackTraceExample.js:2)
  `}
  outputType="error"
/>

Notice how the function name `doSomething` appears in the error output.

The anonymous version isn't so clear. The output will vary depending on your environment, but you'll probably see something like this:

<CodeBlock
  code={`
    setTimeout(() => {
      throw new Error("oh no");
    });
  `}
  language="js"
  output={`
    Error: oh no
        at stackTraceExample.js:2
  `}
  outputType="error"
/>

If you write a lot of your code in `index.js` files, and you run into a more generic error, you can end up with a stack trace that gives you little to go on.

<CodeBlock
  output={`
    SyntaxError: invalid assignment left-hand side
        at index.js:2
  `}
  outputType="error"
/>

Admittedly, most of the time there's still a way to track the error down. The error message itself often gives you a useful clue, like a variable name. Maybe you can narrow your search down to recently changed lines of code.

But sometimes seeing a function or file name is the thing that points you in the right direction. Every now and again, it's the best (or only!) clue you get. And in any case, it's a lot easier to scan for "my code" in a long stack trace when familiar names jump out at you.

[example]

## Anonymous React components

I've seen this style of writing React components cropping up lately, where the function is written as an anonymous default export.

```jsx
import React from "react";
export default () => <p>Hello world</p>;
```

Components like this are pretty awkward to find in React Dev Tools.

[screenshot of anonymous component tree]

This is harder to defend: dropping the name doesn't add an obvious readability improvement this time, and the tooling pain is a pretty clear downside.

## Conclusions

I still write a lot of anonymous functions.
