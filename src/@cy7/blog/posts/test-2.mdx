---
title: "Yet another blog post"
description: "The newest one."
slug: "test-2"
date: "2020-10-19"
---

import { CodeBlock } from "@cy7/blog";

Anonymous functions are commonly used to tidy up callback-heavy JS.

```js
// With named functions
array
  .filter(function notNull(x) {
    return x !== null;
  })
  .map(function double(x) {
    return x * 2;
  });

// The same code with anonymous functions
array
  .filter(x => x !== null)
  .map(x => x * 2);
```

You'll often see anonymous functions written in the more compact [arrow function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) form. But note that arrow functions themselves aren't necessarily anonymous.

<CodeBlock
  code={`
    // A named arrow function.
    // The name comes from the assigned variable.
    let double = x => x * 2;
    console.log(double.name);
  `}
  language="js"
  output={`
    "double"
  `}
/>

## Stack traces

Function names can make stack traces easier to read. Here's what happens when a **named** callback throws an exception.

<CodeBlock
  code={`
    const doSomething = () => {
      throw new Error("oh no");
    };
    setTimeout(doSomething);
  `}
  language="js"
  output={`
    Error: oh no
        at doSomething (stackTraceExample.js:2)
  `}
  outputType="error"
/>

Notice how the function name `doSomething` appears in the error output.

The anonymous version isn't so clear. The output will vary depending on your environment, but you'll probably see something like this:

<CodeBlock
  code={`
    setTimeout(() => {
      throw new Error("oh no");
    });
  `}
  language="js"
  output={`
    Error: oh no
        at stackTraceExample.js:2
  `}
  outputType="error"
/>

If you write a lot of your code in `index.js` files, and you run into a more generic error, you can end up with a stack trace that gives you little to go on.

<CodeBlock
  output={`
    SyntaxError: invalid assignment left-hand side
        at index.js:2
  `}
  outputType="error"
/>

Admittedly, there's usually a way to track the offending code down from a stack trace, function name or no. The error message itself often gives useful clues. Maybe you can narrow your search down to recently changed lines of code.

But sometimes there aren't many clues, and a function name can be the thing that points you in the right direction. In any case, it's a lot easier to scan for "my code" in a long stack trace when familiar names jump out at you.

## Anonymous React components

I often see React code where components are written as anonymous default exports.

```jsx
import React from "react";
export default () => <p>Hello world</p>;
```

Components like this are pretty awkward to find in React Dev Tools. They get named something like `_default` or `Anonymous`. That means you can't really search for them. Too many of them and reading through the tree becomes hard too.

```
// React Dev Tools with named components...
Stack
  Box
    Card
      Avatar
        ...

// ...vs with anonymous components.
_default
  _default
    _default
      Anonymous
        ...
```

## Are anonymous functions always bad then?

Not really. I use them a lot. In the very first example, I'd pick the anonymous version. It's easier to read, and not much can go wrong with `map(x => x * 2)`.

This style of test code encouraged my many JS testing frameworks also uses anonymous callbacks.

```js
test("should return true", () => {
  assert.equal(doThing(), true);
});
```

That's also fine: in practice the `"should return true"` name gets printed in the error output along with the filename. You won't have any trouble locating a failing test.

## Conclusions

Naming your functions means that your tools can help you more.
